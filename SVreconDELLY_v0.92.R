SVreconDELLY <- function(vcf_file, output_folder) {
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Title:			SVreconDELLY
# Version:			v0.92 
# Author:			Jesper Bramsen (bramsen@clin.au.dk)
# Date:			2025-05-01
# Last Update:		2025-05-01
# Dependencies in R:	"dplyr", "stringr", "data.table", "GenomicRanges", "BSgenome.Hsapiens.UCSC.hg38","tidyr","Biostrings"
# Built:			Built and tested using R v4.4.2; dplyr v1.1.4; stringr v1.5.1; data.table v1.16.2; GenomicRanges v1.56.2; BSgenome.Hsapiens.UCSC.hg38 v1.4.5; tidyr v1.3.1 ,Biostrings v2.72.1
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The R function "SVreconDelly" filters Somatic Structural variant (SV) calls predicted by DELLY by attempting to reconstruct their predicted CONTIG sequence from reference genomic sequences and, if successfull, outputs genomic postions and sequences that can be used for downstream BLAST and mutspy analysis, as described in Ellegaard et al. 
# The filtering is strict and will strongly favor simple SVs, where the predicted SV contig ("CONSENSUS" in the input .vcf file "INFO" field) can be fully reconstructed using only the information in the input .vcf file and GRCh38 reference genome sequences.     

# Input for SVreconDELLY is two arguments:
# Argument 1: vcf_file ("path/to/your/file.vcf")
# - The input .vcf or .vcf.gz file must be generated by Delly (PMID: 22962449) and contain only somatic SV calls (i.e. "SOMATIC" in "INFO" FIELD). Only SVs with a predicted CONSENSUS in the INFO FIELD can be processed. The pipeline was built using SVMETHOD=EMBL.DELLYv0.9.1.  
# Argument 2: output_folder ("your/output/folder/")
# - Three output files per sample is written to the output folder (see below).
#
# In overview, SVreconDELLY will: 
# 1) Process only SVs with a "CONSENSUS" sequence (SV contig) in the INFO field and removes SVs marked as “IMPRECISE”. Retain only SVs with FILTER == "PASS" 
# 2) Optionally, filter SVs by MinMAPQ and srMAPQ scores in the INFO field (default MinMAPQ = 0).
# 3) Reconstruct the predicted SV using only breakpoints from the input VCF and the GRCh38 reference genome.
# 4) Attempt to use the reconstructed SV to insert SV breakpoint positions and perfect homology regions (HOMSEQ) between donor sites into the SV contig ("CONSENSUS" in INFO field). Next, extract SV breakpoint flanking sequences for downstream mutspy analysis in the output "SampleID_DELLYrecon_SVmutspy.txt"
# 5) Generate genomic positions of SV donor sites for whole-genome coverage analysis. Output is stored in the output file "SampleID_DELLYrecon_DONOR.bed"
# 6) Produce 50mer+ breakpoint-centered SV contig (with predicted homology) for downstream filtering e.g. by pangenome BLAST as in Ellegaard et al. Output is stored in the output file "SampleID_DELLYrecon_SV50.fa"

# The SVreconDelly output the following three files in "output_folder" using the .vcf filename (without its extension) as the SampleID: 
# 1) "SampleID_DELLYrecon_SVmutspy.txt" contains information from the SV reconstruction analysis, including SV motifs to serve as input for SV mutspy.
# 2) "SampleID_DELLYrecon_DONOR.bed" contains SV donor genomic positions in BED format, suitable for input into WGS coverage analysis..  
# 3) "SampleID_DELLYrecon_SV50.fa" contains truncated SV contigs (≥ 50 bp) in FASTA format, ready for BLAST searches against reference genomes.

# Specifically, the output "SampleID_DELLYrecon_SVmutspy.txt" has the follwoing columns 
# Column 1:		"SV_predictions_tool"			: Tool used for generation of the input .vcf file containing predctions of somatic SVs, here "DELLY"
# Column 2: 	"SVrecon_pipeline" 			: SVrecon_pipeline_version
# Column 3:		"SVrecon_Parameters"			: Values for "GenomicFlank", "CountFlank", "maxHom" and "MinMAPQ" used in SVrecon analysis 
# Column 4:		"Sample_ID" 				: "sampleID" taken from the vcf file name
# Column 5:		"SV_ID"	 				: The ID of the SV extracted from the ID columns of the input .vcf file
# Column 6:		"Genomic_Position1"			: Genomic position of the donor site 1 extracted from the "CHROM" and "POS" columns of the input .vcf file
# Column 7:		"Genomic_Position2"			: Genomic position of the donor site 2 extracted from the "INFO" field of the input .vcf file
# Column 8:		"SVtype"					: The SVtype as annotated in the "INFO" field of the input .vcf file
# Column 9:		"SVtypeClass"				: The SVtypeClass annotated by SVreconDelly during processing of the SVs.
# Column 10:	"SVLEN"					: The SVLEN as annotated in the "INFO" field of the input .vcf file
# Column 11:	"SV_length_estimate"			: Approximate estimate of SV length calculated as the difference between "Genomic_Position1" and "Genomic_Position2"
# Column 12:	"SV_CONTIG"					: The SV consensus sequences extrated from the input .vcf file "INFO" field
# Column 13:	"SV_CONTIG_w.Pred.BreakSite		: The SV consensus sequences extrated from the VCF INFO field, where the SV breakpoint (BP) is predicted by SV reconstruction and indicated with brackets []. Predicted Homology regions are located within brackets.
# Column 14:	"Pred.Breakpoint_Quality"		: Rough estimate of the validity of the predicted breakpoint in the SV CONTIG, divided into three catagories "Good", "Fair" and "Poor". 
# Column 15:	"SV_mutspy_input"				: SV sequence motif that can be used as input in mutspy analysis (as described in Ellegaard et al.) 
#
# Run SVreconDELLY in R (upon installing all dependencies) by running the following two R commands:
# source("path/to/SVreconDELLY_v92.R")
# SVreconDELLY("path/to/your/file.vcf","your/output/folder/")
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 
# --------------------------------------------
# 1. Set parameters and load required packages
# --------------------------------------------
CountFlank=3		# The number of DNA bases on each site of the predicted SV breakpoint that is included in the SVmutspy and DONORbed outputs, in addition to any homology regions (HOMSEQ). Set to 3 by default, which generates output sequences of 3+3=6 bp for SVs with no homology regions between SV donors.
GenomicFlank=200 		# The size for the flanking sequences on each side of the predicted SV breakpoint to be included in the reconstructed SV resequence (set to 200 by default).  
maxHom=1000 		# The size of the DNA sequence used to identify perfectly matching homology between the SV donor sites (set to 1000 by default)
MinMAPQ=0 			# Filter SV based on MinMAPQ and srMAPQ values in the INFO FIELD of the input .vcf file. SV with either MinMAPQ or srMAPQ values below "MinMAPQ" will be removed (set to 0 by default).
library(dplyr)
library(tidyr)
library(stringr)
library(data.table)
library(Biostrings)
library(GenomicRanges)
library(BSgenome.Hsapiens.UCSC.hg38)

# -------------------------------
# 2. Load and organize input data
# -------------------------------
# Load vcf file
dellyvcf <- as.data.frame(read.table(if (grepl("\\.vcf\\.gz$", vcf_file, ignore.case = TRUE)) {gzfile(vcf_file)} else {file(vcf_file)},sep="\t",header=FALSE,comment.char="#",stringsAsFactors=FALSE,quote="",check.names=FALSE ),stringsAsFactors=FALSE)
dellyvcf <- data.frame(lapply(dellyvcf, function(x) gsub("\\s+", "", x)))
names(dellyvcf)[1:8] <- c("CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO")
sample_ID <- sub("\\.vcf(?:\\.gz)?$", "", basename(vcf_file))
# Add parameter columns
dellyvcf$pipeline  <- "DELLY"
dellyvcf$SVrecon_pipeline <- "SVreconDelly_v0.92"
dellyvcf$parameters <- with(dellyvcf,paste0("CountFlank=", CountFlank, ";","GenomicFlank=", GenomicFlank, ";","maxHom=", maxHom, ";","MinMAPQ=", MinMAPQ))
dellyvcf$sample_ID <- sub("\\.vcf(?:\\.gz)?$", "", basename(vcf_file))
dellyvcf$GenPos1    <- with(dellyvcf, paste0(CHROM, ":", POS))

# -----------------------------
# 3. SV candidate pre-filtering 
# -----------------------------
# Keep only SV calls with FILTER == "PASS"
dellyvcfPass <- subset(dellyvcf, FILTER == "PASS")
# Remove imprecise calls
dellyvcfPassPrecise <- subset(dellyvcfPass, !grepl("IMPRECISE", INFO))
# Extract MAPQ & srMAPQ and filter by SV candidates by "MinMAPQ" threshold
if(is.numeric(MinMAPQ)==TRUE) {dellyvcfPassPrecise <- dellyvcfPassPrecise %>% mutate(MAPQ=as.integer(coalesce(str_extract(INFO,"(?<=MAPQ=)\\d+"),"0")), srMAPQ=as.integer(coalesce(str_extract(INFO,"(?<=srmapq=)\\d+"),"0"))) %>%  # extract qualities
  filter(MAPQ>=MinMAPQ, srMAPQ>=MinMAPQ) %>%  # apply minimum threshold
  select(-MAPQ, -srMAPQ)}  # remove temporary columns

# -----------------------
# 4.Standardize INFO keys
# -----------------------
# Standardize INFO keys to lowercase to ease parsing
info_keys <- c("CIEND=", "CIPOS=", "HOMLEN=", "SRMAPQ")
for (key in info_keys) {
 newkey <- tolower(sub("=$", "=", key))
 dellyvcfPassPrecise$INFO <- gsub(key, newkey, dellyvcfPassPrecise$INFO)}
# ----------------------------------------------------------------------------
# 5. Separate SV types (ALT-tagged (INTERX) vs. ALT-untagged SVs (non-INTERX))
# ----------------------------------------------------------------------------
# ALT-tagged: inter-chromosomal SVs (INTERX); noALT-tagged: All INTRAX including DEL, INS and DUP SVs
idx_alt <- grepl("chr", dellyvcfPassPrecise$ALT)
delly_alt <- dellyvcfPassPrecise[idx_alt, ]
delly_noalt <- dellyvcfPassPrecise[!idx_alt, ]

# ---------------------------------------------------------------------------------------
# 6. Parse ALT-tagged calls: extract chr2 and pos2 from ALT string and assign SVtypeClass
# ---------------------------------------------------------------------------------------
# Extract Alt-tagged genomic position for ALT field
delly_alt$CHR2 <- do.call(rbind,strsplit((gsub("\\[|\\]|[ATCGU]", "", delly_alt$ALT)),":",fixed=TRUE))[,1]
delly_alt$POS2 <- do.call(rbind,strsplit((gsub("\\[|\\]|[ATCGU]", "", delly_alt$ALT)),":",fixed=TRUE))[,2]
# Tag each row as intra- or inter-chromosomal SV
delly_alt$SVtypeClass <- ifelse(delly_alt$CHROM == delly_alt$CHR2,"INTRAX","INTERX")

# --------------------------------------------------------------------------------
# 7. Parse noALT-tagged calls: extract pos2 from INFO field and assign SVtypeClass
#---------------------------------------------------------------------------------
delly_noalt$CHR2 <- delly_noalt$CHROM
delly_noalt$POS2 <- as.numeric(as.numeric(gsub("END=","",(unlist(stringr::str_split(delly_noalt$INFO,";", n = Inf, simplify = FALSE))[str_detect(unlist(stringr::str_split(delly_noalt$INFO,";", n = Inf, simplify = FALSE)),"END=", negate = FALSE)]))))
delly_noalt$SVtypeClass <- stringr::str_remove(stringr::str_extract(delly_noalt$INFO, "SVTYPE=[^;]+"),"^SVTYPE=" )

# -----------------------------------------------------------------------------------------------------------------------------
# 8. combine ALT and noALT SV predictions, estimate length and remove SVs with non-reference mapping (non-standard chromosomes)
# -----------------------------------------------------------------------------------------------------------------------------
dellyData=rbind(delly_noalt,delly_alt)

dellyData$SVtype <- str_remove(str_extract(dellyData$INFO, "SVTYPE=[^;]+"),"^SVTYPE=")
dellyData$length <- ifelse(dellyData$SVtypeClass == "INTERX","Irrelevant",as.numeric(dellyData$POS2) - as.numeric(dellyData$POS))
dellyData <- dellyData[dellyData$CHROM %in% paste0("chr", c(1:22, "X", "Y")) &  dellyData$CHR2   %in% paste0("chr", c(1:22, "X", "Y")),]
dellyData <- dellyData[order(dellyData$ID), ]

# ---------------------------------------------------------------------------
# 9. Extract CONTIG, SVLEN, HOMOLOGY OR INSERTED SEQUENCE from the INFO field
# ---------------------------------------------------------------------------
dellyData$CONTIG <- ifelse(grepl("CONSENSUS=", dellyData$INFO), sub(".*(?:^|;)CONSENSUS=([^;]+).*", "\\1", dellyData$INFO), "0")
dellyData$SVLEN <- rep("NA", dim(dellyData)[1]) 
dellyData$HOMSEQ <- vapply(as.integer(coalesce(str_extract(dellyData$INFO, "(?<=homlen=)\\d+"), "0") ), function(n) paste(rep("N", n), collapse = ""),  character(1)) 
dellyData$SVINSSEQ <- vapply(as.integer(coalesce(str_extract(dellyData$INFO, "(?<=INSLEN=)\\d+"),"0")), function(n) paste(rep("N", n), collapse = ""), character(1))  
# ---------------------------------------------------------------------------------------------------------------
# 10. Analyse Delly SVtypeClass DEL (1 configuration format) to reconstruct SVs from the GRChg38 reference genome
# ---------------------------------------------------------------------------------------------------------------
DELdellyData=dellyData[dellyData$SVtypeClass == "DEL" & dellyData$pipeline == "DELLY" ,]
if(dim(DELdellyData)[1]>0) { 
DELdellyData$CHR1adj <- DELdellyData$CHROM
DELdellyData$POS1adj <- as.numeric(DELdellyData$POS)
DELdellyData$CHR2adj <- DELdellyData$CHR2
DELdellyData$POS2adj <- as.numeric(DELdellyData$POS2)
post1 <- as.character(getSeq(Hsapiens, DELdellyData$CHR1adj,start = DELdellyData$POS1adj + 1,	end = DELdellyData$POS1adj + maxHom))
post2 <- as.character(getSeq(Hsapiens, DELdellyData$CHR2adj,start = DELdellyData$POS2adj,		end = DELdellyData$POS2adj + maxHom - 1))
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
DELdellyData$HOMSEQ <- as.character(homologySeq)
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
DELdellyData$PredContig_UpperSEQ_homology_flank <- with(DELdellyData,as.character(getSeq(Hsapiens, CHR1adj, POS1adj - GenomicFlank + 1, POS1adj + nchar(HOMSEQ) + CountFlank))) 
DELdellyData$PredContig_LowerSEQ_homology_flank <- with(DELdellyData,as.character(getSeq(Hsapiens, CHR2adj, POS2adj - CountFlank, POS2adj + nchar(HOMSEQ) + GenomicFlank - 1)))
DELdellyData$PREDSV <- with(DELdellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
DELdellyData$DONORPOS1  <- with(DELdellyData,paste0(CHR1adj,":",POS1adj-CountFlank+1,"-",POS1adj+nchar(HOMSEQ)+CountFlank))
DELdellyData$DONORSEQ1  <- with(DELdellyData,substr(PredContig_UpperSEQ_homology_flank,nchar(PredContig_UpperSEQ_homology_flank)-2*CountFlank-nchar(HOMSEQ)+1,nchar(PredContig_UpperSEQ_homology_flank)))
DELdellyData$DONORPOS2  <- with(DELdellyData,paste0(CHR2adj,":",POS2adj-CountFlank,"-",POS2adj+nchar(HOMSEQ)+CountFlank-1))
DELdellyData$DONORSEQ2  <- with(DELdellyData,substr(PredContig_LowerSEQ_homology_flank,1, (nchar(HOMSEQ)+(2*CountFlank))))
} else {DELdellyData=NULL}

# ---------------------------------------------------------------------------------------------------------------
# 11. Analyse Delly typeClassSV DUP (1 configuration format) to reconstruct SVs from the GRChg38 reference genome
# ---------------------------------------------------------------------------------------------------------------
DUPdellyData=dellyData[dellyData$SVtypeClass == "DUP" & dellyData$pipeline == "DELLY" ,]
if(dim(DUPdellyData)[1]>0) { 
DUPdellyData$CHR1adj <- DUPdellyData$CHR2
DUPdellyData$POS1adj <- as.numeric(DUPdellyData$POS2)
DUPdellyData$CHR2adj <- DUPdellyData$CHROM
DUPdellyData$POS2adj <- as.numeric(DUPdellyData$POS)
#Predict longest perfect homology regions and replace extracted HOMSEQ with predicted homology sequence
post1 <- as.character(getSeq(Hsapiens, DUPdellyData$CHR1adj,start = DUPdellyData$POS1adj + 1,end=DUPdellyData$POS1adj + maxHom))
post2 <- as.character(getSeq(Hsapiens, DUPdellyData$CHR2adj,start = DUPdellyData$POS2adj,end=DUPdellyData$POS2adj + maxHom - 1))
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
DUPdellyData$HOMSEQ  <- as.character(homologySeq)
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
DUPdellyData$PredContig_UpperSEQ_homology_flank <- with(DUPdellyData,as.character(getSeq(Hsapiens, CHR1adj, POS1adj - GenomicFlank - 1, POS1adj + nchar(HOMSEQ) + CountFlank))) 
DUPdellyData$PredContig_LowerSEQ_homology_flank <- with(DUPdellyData,as.character(getSeq(Hsapiens, CHR2adj, POS2adj - CountFlank, POS2adj + nchar(HOMSEQ) + GenomicFlank -1)))
DUPdellyData$PREDSV  <- with(DUPdellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
DUPdellyData$DONORPOS1  <- with(DUPdellyData,paste0(CHR1adj,":",POS1adj-CountFlank+1,"-",POS1adj+nchar(HOMSEQ)+CountFlank))
DUPdellyData$DONORSEQ1  <- with(DUPdellyData,substr(PredContig_UpperSEQ_homology_flank,nchar(PredContig_UpperSEQ_homology_flank)-2*CountFlank-nchar(HOMSEQ)+1,nchar(PredContig_UpperSEQ_homology_flank)))
DUPdellyData$DONORPOS2  <- with(DUPdellyData,paste0(CHR2adj,":",POS2adj-CountFlank,"-",POS2adj+nchar(HOMSEQ)+CountFlank-1))
DUPdellyData$DONORSEQ2  <- with(DUPdellyData,substr(PredContig_LowerSEQ_homology_flank,1, (nchar(HOMSEQ)+(2*CountFlank))))
} else {DUPdellyData=NULL}

# ----------------------------------------------------------------------------------------------------------------
# 12. Analyse Delly typeClassSV INV (2 configuration formats) to reconstruct SVs from the GRChg38 reference genome
# ----------------------------------------------------------------------------------------------------------------
INVdellyData=dellyData[dellyData$SVtypeClass == "INV" & dellyData$pipeline == "DELLY" ,]
if(dim(INVdellyData)[1]>0) {
INV1dellyData=INVdellyData[INVdellyData$INFO %like% "CT=3to3",]
INV2dellyData=INVdellyData[INVdellyData$INFO %like% "CT=5to5",]
} else {
INV1dellyData=NULL
INV2dellyData=NULL
}
#Process annotation type INV11 
if(dim(INV1dellyData)[1]>0) { 
INV1dellyData$CHR1adj <- INV1dellyData$CHROM 	
INV1dellyData$POS1adj <- as.numeric(INV1dellyData$POS)
INV1dellyData$CHR2adj <- INV1dellyData$CHR2 
INV1dellyData$POS2adj <- as.numeric(INV1dellyData$POS2)
#Predict longest perfect homology regions and replace extracted HOMSEQ with predicted homology sequence
post1 <- as.character(getSeq(Hsapiens, INV1dellyData$CHR1adj,start = INV1dellyData$POS1adj + 1,end=INV1dellyData$POS1adj + maxHom))
post2 <- as.character(getSeq(Hsapiens, INV1dellyData$CHR2adj,start = INV1dellyData$POS2adj - maxHom +1 ,end=INV1dellyData$POS2adj, strand = "-"))
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
INV1dellyData$HOMSEQ <- as.character(homologySeq)
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
INV1dellyData$PredContig_UpperSEQ_homology_flank <- with(INV1dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - GenomicFlank + 1, POS1adj + nchar(HOMSEQ) + CountFlank)))
INV1dellyData$PredContig_LowerSEQ_homology_flank <- with(INV1dellyData, as.character(getSeq(Hsapiens, CHR2adj, POS2adj -(GenomicFlank-1)-nchar(HOMSEQ), POS2adj  + CountFlank , strand = "-")))
INV1dellyData$PREDSV  <- with(INV1dellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
INV1dellyData$DONORPOS1  <- with(INV1dellyData,paste0(CHR1adj,":",POS1adj-CountFlank+1,"-",POS1adj+nchar(HOMSEQ)+CountFlank)) #OK
INV1dellyData$DONORSEQ1  <- with(INV1dellyData,substr(PredContig_UpperSEQ_homology_flank,nchar(PredContig_UpperSEQ_homology_flank)-2*CountFlank-nchar(HOMSEQ)+1,nchar(PredContig_UpperSEQ_homology_flank))) 
INV1dellyData$DONORPOS2  <- with(INV1dellyData,paste0(CHR2adj,":",(POS2adj-CountFlank+1-nchar(HOMSEQ)),"-",POS2adj+CountFlank))
INV1dellyData$DONORSEQ2 <- with(INV1dellyData, as.character(reverseComplement(DNAStringSet(substr(PredContig_LowerSEQ_homology_flank, 1, nchar(HOMSEQ) + 2*CountFlank)))))
} else {INV1dellyData=NULL}
#Process annotation type INV2 
if(dim(INV2dellyData)[1]>0) { 
INV2dellyData$CHR1adj <- INV2dellyData$CHROM 	
INV2dellyData$POS1adj <- as.numeric(INV2dellyData$POS)
INV2dellyData$CHR2adj <- INV2dellyData$CHR2					 
INV2dellyData$POS2adj <- as.numeric(INV2dellyData$POS2)			
#Predict longest perfect homology regions and replace extracted HOMSEQ with predicted homology sequence
post1 <- as.character(getSeq(Hsapiens, INV2dellyData$CHR1adj,start = INV2dellyData$POS1adj-maxHom,end=INV2dellyData$POS1adj-1, strand = "-")) 
post2 <- as.character(getSeq(Hsapiens, INV2dellyData$CHR2adj,start = INV2dellyData$POS2adj,end=INV2dellyData$POS2adj+maxHom-1, strand = "+")) 
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
INV2dellyData$HOMSEQ <- as.character(homologySeq)
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
INV2dellyData$PredContig_UpperSEQ_homology_flank <- with(INV2dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - nchar(HOMSEQ) - CountFlank, POS1adj + GenomicFlank - 1, strand="-")))	
INV2dellyData$PredContig_LowerSEQ_homology_flank <- with(INV2dellyData, as.character(getSeq(Hsapiens, CHR2adj, POS2adj - CountFlank, POS2adj + nchar(HOMSEQ)+ GenomicFlank -1 , strand="+"))) 	
INV2dellyData$PREDSV  <- with(INV2dellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
INV2dellyData$DONORPOS1 <- with(INV2dellyData, paste0(CHR1adj, ":", POS1adj - nchar(HOMSEQ) - CountFlank, "-", POS1adj + CountFlank - 1))
INV2dellyData$DONORSEQ1 <- with(INV2dellyData, as.character(reverseComplement(DNAStringSet(substr(PredContig_UpperSEQ_homology_flank, nchar(PredContig_UpperSEQ_homology_flank) - 2*CountFlank - nchar(HOMSEQ) + 1, nchar(PredContig_UpperSEQ_homology_flank)))))) #
INV2dellyData$DONORPOS2 <- with(INV2dellyData, paste0(CHR2adj, ":", POS2adj - CountFlank, "-", POS2adj + nchar(HOMSEQ)+CountFlank - 1))		
INV2dellyData$DONORSEQ2 <- with(INV2dellyData, substr(PredContig_LowerSEQ_homology_flank, 1, 2*CountFlank + nchar(HOMSEQ))) 				
} else {INV2dellyData=NULL}

# -------------------------------------------------------------------------------------------------------------------
# 13. Analyse Delly typeClassSV INTERX (4 configuration formats) to reconstruct SVs from the GRChg38 reference genome
# -------------------------------------------------------------------------------------------------------------------
INTERXdellyData=dellyData[dellyData$SVtypeClass == "INTERX" & dellyData$pipeline == "DELLY" ,]
if(dim(INVdellyData)[1]>0) {
INTERX1dellyData=INTERXdellyData[INTERXdellyData$INFO %like% "CT=3to3",]
INTERX2dellyData=INTERXdellyData[INTERXdellyData$INFO %like% "CT=5to5",]
INTERX3dellyData=INTERXdellyData[INTERXdellyData$INFO %like% "CT=3to5",]
INTERX4dellyData=INTERXdellyData[INTERXdellyData$INFO %like% "CT=5to3",]
} else {
INTERX1dellyData=NULL
INTERX2dellyData=NULL
INTERX3dellyData=NULL
INTERX4dellyData=NULL
}
#Process annotation type INTERX1 
if(dim(INTERX1dellyData)[1]>0) { 
INTERX1dellyData$CHR1adj <- INTERX1dellyData$CHROM 	
INTERX1dellyData$POS1adj <- as.numeric(INTERX1dellyData$POS)
INTERX1dellyData$CHR2adj <- INTERX1dellyData$CHR2			
INTERX1dellyData$POS2adj <- as.numeric(INTERX1dellyData$POS2)
# Predict longest perfect homology regions and replace extracted HOMSEQ with predicted homology sequence
post1 <- as.character(getSeq(Hsapiens, INTERX1dellyData$CHR1adj,start = INTERX1dellyData$POS1adj+1,end=INTERX1dellyData$POS1adj + maxHom, strand = "+")) 
post2 <- as.character(getSeq(Hsapiens, INTERX1dellyData$CHR2adj,start = INTERX1dellyData$POS2adj-maxHom+1,end=INTERX1dellyData$POS2adj, strand = "-")) 
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
INTERX1dellyData$HOMSEQ <- as.character(homologySeq)
# Adjust POS2adj according to "HOMSEQ" length
INTERX1dellyData$POS2adj <- as.numeric(INTERX1dellyData$POS2)-as.numeric(nchar(INTERX1dellyData$HOMSEQ))
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
INTERX1dellyData$PredContig_UpperSEQ_homology_flank <- with(INTERX1dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - GenomicFlank + 1, POS1adj + nchar(HOMSEQ)+ CountFlank, strand="+")))	
INTERX1dellyData$PredContig_LowerSEQ_homology_flank <- with(INTERX1dellyData, as.character(getSeq(Hsapiens, CHR2adj, POS2adj - GenomicFlank + 1, POS2adj + nchar(HOMSEQ)+ CountFlank, strand="-"))) 	
INTERX1dellyData$PREDSV=with(INTERX1dellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
INTERX1dellyData$DONORPOS1 <- with(INTERX1dellyData, paste0(CHR1adj, ":", POS1adj - CountFlank + 1, "-", POS1adj + nchar(HOMSEQ) + CountFlank))
INTERX1dellyData$DONORSEQ1 <- with(INTERX1dellyData, substr(PredContig_UpperSEQ_homology_flank, nchar(PredContig_UpperSEQ_homology_flank) - 2*CountFlank - nchar(HOMSEQ) + 1, nchar(PredContig_UpperSEQ_homology_flank)))
INTERX1dellyData$DONORPOS2 <- with(INTERX1dellyData, paste0(CHR2adj, ":", POS2adj - CountFlank + 1, "-", POS2adj + CountFlank + nchar(HOMSEQ)))
INTERX1dellyData$DONORSEQ2 <- with(INTERX1dellyData, as.character(reverseComplement(DNAStringSet(substr(PredContig_LowerSEQ_homology_flank, 1, 2*CountFlank + nchar(HOMSEQ))))))
} else {INTERX1dellyData=NULL}
#Process annotation type INTERX2
if(dim(INTERX2dellyData)[1]>0) { 
INTERX2dellyData$CHR1adj <- INTERX2dellyData$CHROM 	
INTERX2dellyData$POS1adj <- as.numeric(INTERX2dellyData$POS)
INTERX2dellyData$CHR2adj <- INTERX2dellyData$CHR2			
INTERX2dellyData$POS2adj <- as.numeric(INTERX2dellyData$POS2)
# Find perfect matching homology region HOMSEQ
post1 <- as.character(getSeq(Hsapiens, INTERX2dellyData$CHR1adj,start = INTERX2dellyData$POS1adj-maxHom,end=INTERX2dellyData$POS1adj-1, strand = "-")) 
post2 <- as.character(getSeq(Hsapiens, INTERX2dellyData$CHR2adj,start = INTERX2dellyData$POS2adj,end=INTERX2dellyData$POS2adj+maxHom-1, strand = "+")) 
# find the longest common prefix
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
#replace HOMSEQ with calculated homologySeq
INTERX2dellyData$HOMSEQ <- as.character(homologySeq)
#Adjustment of POS2adj according to HOMSEQ lengh
INTERX2dellyData$POS2adj <- as.numeric(INTERX2dellyData$POS2) + as.numeric(nchar(INTERX2dellyData$HOMSEQ))
#Extract Flanking sequence
INTERX2dellyData$PredContig_UpperSEQ_homology_flank <- with(INTERX2dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - nchar(HOMSEQ) - CountFlank, POS1adj + (GenomicFlank - 1), strand="-"))) #OK2025
INTERX2dellyData$PredContig_LowerSEQ_homology_flank <- with(INTERX2dellyData, as.character(getSeq(Hsapiens, CHR2adj, POS2adj - nchar(HOMSEQ) - CountFlank, POS2adj + (GenomicFlank - 1), strand="+"))) #OK2025
#Reconstruct SV from genomic sequences
INTERX2dellyData$PREDSV <- with(INTERX2dellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
INTERX2dellyData$DONORPOS1 <- with(INTERX2dellyData, paste0(CHR1adj, ":", POS1adj - nchar(HOMSEQ) - CountFlank, "-", POS1adj + CountFlank - 1))
INTERX2dellyData$DONORSEQ1 <- with(INTERX2dellyData, as.character(reverseComplement(DNAStringSet(substr(PredContig_UpperSEQ_homology_flank, nchar(PredContig_UpperSEQ_homology_flank) - 2*CountFlank - nchar(HOMSEQ) + 1, nchar(PredContig_UpperSEQ_homology_flank))))))
INTERX2dellyData$DONORPOS2 <- with(INTERX2dellyData, paste0(CHR2adj, ":", POS2adj - CountFlank - nchar(HOMSEQ), "-", POS2adj + CountFlank - 1))
INTERX2dellyData$DONORSEQ2 <- with(INTERX2dellyData, substr(PredContig_LowerSEQ_homology_flank, 1, 2*CountFlank + nchar(HOMSEQ))) 
} else {INTERX2dellyData=NULL}
#Process annotation type INTERX3
if(dim(INTERX3dellyData)[1]>0) { 
INTERX3dellyData$CHR1adj <- INTERX3dellyData$CHROM 	
INTERX3dellyData$POS1adj <- as.numeric(INTERX3dellyData$POS)
INTERX3dellyData$CHR2adj <- INTERX3dellyData$CHR2			
INTERX3dellyData$POS2adj <- as.numeric(INTERX3dellyData$POS2)
# Predict longest perfect homology regions and replace extracted HOMSEQ with predicted homology sequence
post1 <- as.character(getSeq(Hsapiens, INTERX3dellyData$CHR1adj,	start = INTERX3dellyData$POS1adj+1,		end=INTERX3dellyData$POS1adj+maxHom, 		strand = "+")) #OK2025
post2 <- as.character(getSeq(Hsapiens, INTERX3dellyData$CHR2adj,	start = INTERX3dellyData$POS2adj,		end=INTERX3dellyData$POS2adj+maxHom-1, 		strand = "+")) #OK2025
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
INTERX3dellyData$HOMSEQ <- as.character(homologySeq)
# Adjustment of POS2adj according to HOMSEQ length
INTERX3dellyData$POS2adj <- as.numeric(INTERX3dellyData$POS2) + as.numeric(nchar(INTERX3dellyData$HOMSEQ))
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
INTERX3dellyData$PredContig_UpperSEQ_homology_flank <- with(INTERX3dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - GenomicFlank + 1, POS1adj + nchar(HOMSEQ) + CountFlank))) 	#OK2025
INTERX3dellyData$PredContig_LowerSEQ_homology_flank <- with(INTERX3dellyData, as.character(getSeq(Hsapiens, CHR2adj, POS2adj - nchar(HOMSEQ) - CountFlank, POS2adj + (GenomicFlank - 1)))) #OK2025
INTERX3dellyData$PREDSV=with(INTERX3dellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
INTERX3dellyData$DONORPOS1 <- with(INTERX3dellyData, paste0(CHR1adj, ":", POS1adj - CountFlank + 1, "-", POS1adj + nchar(HOMSEQ) + CountFlank))
INTERX3dellyData$DONORSEQ1 <- with(INTERX3dellyData, substr(PredContig_UpperSEQ_homology_flank, nchar(PredContig_UpperSEQ_homology_flank) - 2*CountFlank - nchar(HOMSEQ) + 1, nchar(PredContig_UpperSEQ_homology_flank)))
INTERX3dellyData$DONORPOS2 <- with(INTERX3dellyData, paste0(CHR2adj, ":", POS2adj - CountFlank - nchar(HOMSEQ), "-", POS2adj + CountFlank - 1))
INTERX3dellyData$DONORSEQ2 <- with(INTERX3dellyData, substr(PredContig_LowerSEQ_homology_flank, 1, 2*CountFlank + nchar(HOMSEQ)))
} else {INTERX3dellyData=NULL}
#Process annotation type INTERX4
if(dim(INTERX3dellyData)[1]>0) { 
INTERX4dellyData$CHR1adj <- INTERX4dellyData$CHROM 	
INTERX4dellyData$POS1adj <- as.numeric(INTERX4dellyData$POS)
INTERX4dellyData$CHR2adj <- INTERX4dellyData$CHR2			
INTERX4dellyData$POS2adj <- as.numeric(INTERX4dellyData$POS2)
# Predict longest perfect homology regions and replace extracted HOMSEQ with predicted homology sequence
post1 <- as.character(getSeq(Hsapiens, INTERX4dellyData$CHR1adj,	start = INTERX4dellyData$POS1adj+1,		end=INTERX4dellyData$POS1adj+maxHom, 		strand = "+")) 
post2 <- as.character(getSeq(Hsapiens, INTERX4dellyData$CHR2adj,	start = INTERX4dellyData$POS2adj+1,		end=INTERX4dellyData$POS2adj+maxHom, 		strand = "+")) 
getHomLen <- function(a, b, maxN) { r <- min(nchar(a), nchar(b), maxN); sum(cumprod(substring(a, 1:r, 1:r) == substring(b, 1:r, 1:r))) }
homologyLen <- mapply(getHomLen, post1, post2,MoreArgs = list(maxN = maxHom),USE.NAMES = FALSE)
homologySeq <- substring(post1, 1, homologyLen)
INTERX4dellyData$HOMSEQ <- as.character(homologySeq)
# Adjustment of POS2adj according to HOMSEQ length
INTERX4dellyData$POS2adj <- as.numeric(INTERX4dellyData$POS2) + as.numeric(nchar(INTERX4dellyData$HOMSEQ))
# Extract breakpoint-flanking sequence and Reconstruct SV from genomic sequences to generate predicted SV (PREDSV)
INTERX4dellyData$PredContig_UpperSEQ_homology_flank <- with(INTERX4dellyData, as.character(getSeq(Hsapiens, CHR2adj, POS2adj - (GenomicFlank - 1), POS2adj + nchar(HOMSEQ) + CountFlank)))
INTERX4dellyData$PredContig_LowerSEQ_homology_flank <- with(INTERX4dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - nchar(HOMSEQ) - CountFlank+1, POS1adj + GenomicFlank))) #new_version_one_shifted
INTERX4dellyData$PredContig_LowerSEQ_homology_flank <- with(INTERX4dellyData, as.character(getSeq(Hsapiens, CHR1adj, POS1adj - nchar(HOMSEQ) - CountFlank , POS1adj + GenomicFlank -1 ))) #old version need doublecheck
INTERX4dellyData$PREDSV <- with(INTERX4dellyData, paste0(substr(PredContig_UpperSEQ_homology_flank, 1, nchar(PredContig_UpperSEQ_homology_flank) - CountFlank-nchar(HOMSEQ)), "[", HOMSEQ, "]",substr(PredContig_LowerSEQ_homology_flank, CountFlank+nchar(HOMSEQ)+1,nchar(PredContig_LowerSEQ_homology_flank)) ))
# Extract breakpoint-spanning DNAmotif at SV DONOR sites
INTERX4dellyData$DONORPOS1 <- with(INTERX4dellyData, paste0(CHR2adj, ":", POS2adj - CountFlank + 1, "-", POS2adj + nchar(HOMSEQ) + CountFlank))
INTERX4dellyData$DONORSEQ1 <- with(INTERX4dellyData, substr(PredContig_UpperSEQ_homology_flank, nchar(PredContig_UpperSEQ_homology_flank) - 2*CountFlank - nchar(HOMSEQ) + 1, nchar(PredContig_UpperSEQ_homology_flank)))
INTERX4dellyData$DONORPOS2 <- with(INTERX4dellyData, paste0(CHR1adj, ":", POS1adj - CountFlank - nchar(HOMSEQ), "-", POS1adj + CountFlank - 1))
INTERX4dellyData$DONORSEQ2 <- with(INTERX4dellyData, substr(PredContig_LowerSEQ_homology_flank, 1, 2*CountFlank + nchar(HOMSEQ)))
} else {INTERX4dellyData=NULL}

# ---------------------------------------------------------------
# 14. Combine Data and insert predicted BP and homology in CONTIG
# ---------------------------------------------------------------
# Combine Processed SV data 
dellyDataProc=rbind(DELdellyData,DUPdellyData,INV1dellyData,INV2dellyData,INTERX1dellyData,INTERX2dellyData,INTERX3dellyData,INTERX4dellyData)
# Extract eight SV breakpoint flanking or spanning predicted SV sequences. 
PREDSVupMotif8B <- paste0(substr((sv <- as.character(dellyDataProc$PREDSV)), regexpr("\\[", sv) - 8,regexpr("\\[", sv) + nchar(as.character(dellyDataProc$HOMSEQ)) + nchar(as.character(dellyDataProc$SVINSSEQ))  ),  "]")
PREDSVupMotif40v1B <- paste0(substr((sv <- as.character(dellyDataProc$PREDSV)),regexpr("\\[", sv) - 40,regexpr("\\[", sv) + nchar(as.character(dellyDataProc$HOMSEQ)) + nchar(as.character(dellyDataProc$SVINSSEQ))  ),  "]")
PREDSVupMotif40v2B <- as.character(mapply(\(predSV, contig, svseq) paste0(str_sub(contig, str_locate(contig, str_replace(str_sub(predSV, gregexpr("\\[", predSV)[[1]][1]-40, gregexpr("\\[", predSV)[[1]][1]), "\\[", ""))[2]-39, str_locate(contig, str_replace(str_sub(predSV, gregexpr("\\[", predSV)[[1]][1]-40, gregexpr("\\[", predSV)[[1]][1]), "\\[", ""))[2]), "[", str_sub(contig, str_locate(contig, str_replace(str_sub(predSV, gregexpr("\\[", predSV)[[1]][1]-40, gregexpr("\\[", predSV)[[1]][1]), "\\[", ""))[2]+1, str_locate(contig, str_replace(str_sub(predSV, gregexpr("\\[", predSV)[[1]][1]-40, gregexpr("\\[", predSV)[[1]][1]), "\\[", ""))[2]+nchar(svseq)), "]"), dellyDataProc$PREDSV, dellyDataProc$CONTIG, dellyDataProc$SVINSSEQ))
PREDSVmidMotifB <- substr( (sv <- as.character(dellyDataProc$PREDSV)),regexpr("\\[", sv) - CountFlank, regexpr("\\]", sv) + CountFlank)
PREDSVmidMotif40B <- substr((sv <- as.character(dellyDataProc$PREDSV)),regexpr("\\[", sv) - 20,regexpr("\\]", sv) + 20)
PREDSVdnMotif8B <- paste0("[",substr((sv <- as.character(dellyDataProc$PREDSV)),regexpr("\\]", sv) - nchar(as.character(dellyDataProc$HOMSEQ)) - nchar(as.character(dellyDataProc$SVINSSEQ)),    regexpr("\\]", sv) + 8 ))
PREDSVdnMotif40v1B <- paste0("[",substr((sv <- as.character(dellyDataProc$PREDSV)), regexpr("\\]", sv) - nchar(as.character(dellyDataProc$HOMSEQ)) - nchar(as.character(dellyDataProc$SVINSSEQ)),    regexpr("\\]", sv) + 40  ))
PREDSVdnMotif40v2B <- as.character(mapply(\(predSV, contig, svseq) {motif_pos <- str_locate(contig, fixed(str_remove(substr(predSV, gregexpr("\\]", predSV)[[1]][1], gregexpr("\\]", predSV)[[1]][1]+40), "]")))[1];    paste0(        "[", str_sub(contig, motif_pos, motif_pos + nchar(svseq) - 1), "]",        str_sub(contig, motif_pos + nchar(svseq) + 1, motif_pos + 40 + nchar(svseq))    )}, dellyDataProc$PREDSV, dellyDataProc$CONTIG, dellyDataProc$SVINSSEQ, USE.NAMES = FALSE))
# Insert predicted breakpoints (i.e. brackets) in CONTIG using the eight SV breakpoint flanking or spanning predicted SV sequences, remove instances with multiple insertions and remove modified CONTIGs that does not have the same sequence af the original CONTIG after removal of brackets.
filter_exact_brackets <- function(v, o="\\[", c="\\]", r="") ifelse(str_count(v,o)==1 & str_count(v,c)==1, as.character(v), r)
filter_match_ref <- function(v, ref) ifelse(str_remove_all(v, "\\[|\\]") == as.character(ref), as.character(v), "")
CONTIGSVupMotif8B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVupMotif8B),replacement = PREDSVupMotif8B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVupMotif40v1B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVupMotif40v1B),replacement = PREDSVupMotif40v1B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVupMotif40v2B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVupMotif40v2B),replacement = PREDSVupMotif40v2B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVmidMotifB <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVmidMotifB),replacement = PREDSVmidMotifB,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVmidMotif40B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVmidMotif40B),replacement = PREDSVmidMotif40B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVdnMotif8B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVdnMotif8B),replacement = PREDSVdnMotif8B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVdnMotif40v1B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVdnMotif40v1B),replacement = PREDSVdnMotif40v1B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
CONTIGSVdnMotif40v2B <- filter_match_ref(filter_exact_brackets(mapply(gsub,pattern     = gsub("\\[|\\]", "", PREDSVdnMotif40v2B),replacement = PREDSVdnMotif40v2B,x = as.character(dellyDataProc$CONTIG),USE.NAMES   = FALSE)),dellyDataProc$CONTIG)
# Collect only entries containing both “\[” and “\]”, select the most frequent CONTIGB motif and assign confidence of SV reconstruction.
collect_bracket_pairs <- function(..., open="\\[", close="\\]") apply(do.call(cbind, list(...)), 1, function(row) row[str_count(row, open) > 0 & str_count(row, close) > 0])
quality_contigs <- function(preds) vapply(preds, function(x) { n <- sum(str_detect(x, fixed("["))); paste0(ifelse(n>=5, "Good_", ifelse(n>=3, "Fair_", ifelse(n>=1, "Low_", "Failed_"))), "(", n, "/8_recons.)") }, FUN.VALUE=character(1))
CONTIGBallPRED <- collect_bracket_pairs(  CONTIGSVupMotif8B,  CONTIGSVupMotif40v1B,  CONTIGSVupMotif40v2B,  CONTIGSVmidMotifB,  CONTIGSVmidMotif40B,  CONTIGSVdnMotif8B,  CONTIGSVdnMotif40v1B,  CONTIGSVdnMotif40v2B)
dellyDataProc$CONTIGB <- vapply(CONTIGBallPRED, function(p) if ((h <- p[str_detect(p, fixed("["))]) |> length() > 0) names(which.max(table(h))) else "SV_and_breakpoint_not_reconstructed._Please_curate_manually", FUN.VALUE = character(1))
dellyDataProc$CONTIGB_ReconQuality <- quality_contigs(CONTIGBallPRED)

# ----------------------------------------------------------------------------------------
# 15. Extract SV ID, position and DNA sequence motifs for mutspy analysis into output file
# ----------------------------------------------------------------------------------------
dellyDataProc$SAMPLE_SV_ID <- paste0(dellyDataProc$sample_ID,"_",dellyDataProc$ID)
SVmotifupPOS <- as.numeric(sapply(dellyDataProc$CONTIGB, function(x) {str_locate(x,"\\[")[1]}-CountFlank))
SVmotifdnPOS <- as.numeric(sapply(dellyDataProc$CONTIGB, function(x) {str_locate(x,"\\]")[1]}+CountFlank-2))
SAMPLE_SV_ID <- dellyDataProc$SAMPLE_SV_ID
dellyDataProc$SVmotifPOS <- paste0(gsub(":","_",SAMPLE_SV_ID),":",SVmotifupPOS,"-",SVmotifdnPOS)
dellyDataProc$SVmotifSEQ <- substring(dellyDataProc$CONTIG, SVmotifupPOS, SVmotifdnPOS)
dellyDataProc$SVmutspy <- paste0(paste0(gsub(":","_",SAMPLE_SV_ID),":",SVmotifupPOS),"_",strrep("A", nchar(dellyDataProc$SVmotifSEQ)),"/",dellyDataProc$SVmotifSEQ)
dellyDataProc$GenPos2    <- with(dellyDataProc, paste0(CHR2, ":", POS2))
SVmutspy=as.data.frame(dellyDataProc[, c("pipeline","SVrecon_pipeline","parameters","sample_ID","ID","GenPos1","GenPos2","SVtype","SVtypeClass","SVLEN","length","CONTIG","CONTIGB","CONTIGB_ReconQuality","SVmutspy")] )
colnames(SVmutspy)=c("SV_predictions_tool","SVrecon_pipeline","SVrecon_Parameters","Sample_ID","SV_ID", "Genomic_Position1","Genomic_Position2","SVtype","SVtypeClass","SVLEN","SV_length_estimate","SV_CONTIG","SV_CONTIG_w.Pred.BreakSite","Pred.BreakSite_Quality","SV_mutspy_input")
write.table(as.data.frame(SVmutspy), paste0(output_folder,sample_ID,"_DELLYrecon_SVmutspy.txt"), sep="\t", quote=F, row.names=F) 
# ------------------------------------------------------------------------------------------------------------------
# 16. Extract SV DON0R-site genomic positions and generate bed-style output file for WGS coverage analysis
# ------------------------------------------------------------------------------------------------------------------
DONOR1bed <- dellyDataProc %>% separate(DONORPOS1, into = c("chr","start","end"), sep = "[^[:alnum:]]+") %>%   mutate(start = as.numeric(start) - 1, SV_chr_name = paste0(SAMPLE_SV_ID, "_DONOR1motif")) %>%   select(chr, start, end, SV_chr_name)
DONOR2bed <- dellyDataProc %>% separate(DONORPOS2, into = c("chr","start","end"), sep = "[^[:alnum:]]+") %>%   mutate(start = as.numeric(start) - 1, SV_chr_name = paste0(SAMPLE_SV_ID, "_DONOR2motif")) %>%   select(chr, start, end, SV_chr_name)
DONORbed <-rbind(DONOR1bed,DONOR2bed)
write.table(DONORbed, paste0(output_folder,sample_ID,"_DELLYrecon_DONOR.bed"), sep="\t", quote=F, col.names=F,row.names=F) 

# ---------------------------------------------------------------------------------------------------------------
# 17 Extract_SV 50mer+ sequence and generate fasta-style output file for pangenome homology analysis using blastn
# ---------------------------------------------------------------------------------------------------------------
dellyDataProc$SV50mer=substr(dellyDataProc$CONTIG,(SVmotifupPOS+CountFlank-25),SVmotifdnPOS-CountFlank+25)
# Subset to the two columns and drop rows where SV50mer is NA
SV50fasta <- dellyDataProc[, c("SAMPLE_SV_ID","SV50mer")]
SV50fasta <- SV50fasta[!is.na(SV50fasta$SV50mer), ]
# build a one-column “fasta” data.frame with interleaved header+sequence lines
SV50fasta <- as.character(data.frame(line = c(rbind(paste0(">", SV50fasta$SAMPLE_SV_ID),SV50fasta$SV50mer)),stringsAsFactors = FALSE)[,1])
write.table(SV50fasta, paste0(output_folder,sample_ID,"_","_DELLYrecon_SV50.fa"), sep="\t", col.names=F, row.names=F, quote=F) 
######################################################################## 
#Script completed
########################################################################
}

